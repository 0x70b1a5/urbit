diff -ur ld64-274.2-orig/src/ld/InputFiles.cpp ld64-274.2/src/ld/InputFiles.cpp
--- ld64-274.2-orig/src/ld/InputFiles.cpp	2017-09-29 07:44:04.316338766 -0700
+++ ld64-274.2/src/ld/InputFiles.cpp	2017-10-23 20:10:32.663219382 -0700
@@ -29,6 +29,7 @@
 #include <sys/stat.h>
 #include <sys/mman.h>
 #include <sys/sysctl.h>
+#include <sys/param.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <limits.h>
@@ -215,7 +216,7 @@
 	if ( fd == -1 )
 		throwf("can't open file, errno=%d", errno);
 	if ( info.fileLen < 20 )
-		throwf("file too small (length=%llu)", info.fileLen);
+		throwf("file too small (length=%lu)", info.fileLen);
 
 	uint8_t* p = (uint8_t*)::mmap(NULL, info.fileLen, PROT_READ, MAP_FILE | MAP_PRIVATE, fd, 0);
 	if ( p == (uint8_t*)(-1) )
@@ -264,7 +265,7 @@
 					newFileLen = statBuffer.st_size;
 				}
 				if ( fileOffset+len > newFileLen ) {
-					throwf("truncated fat file. Slice from %u to %llu is past end of file with length %llu", 
+					throwf("truncated fat file. Slice from %u to %lu is past end of file with length %lu", 
 						fileOffset, fileOffset+len, info.fileLen);
 				}
 			}
@@ -422,7 +423,7 @@
 {
 	if ( _options.traceDylibs() ) {
 		const char* fullPath = file->path();
-		char realName[MAXPATHLEN];
+		char realName[PATH_MAX];
 		if ( realpath(fullPath, realName) != NULL )
 			fullPath = realName;
 		const ld::dylib::File* dylib = dynamic_cast<const ld::dylib::File*>(file);
@@ -472,7 +473,7 @@
 		// <rdar://problem/4947347> LD_TRACE_ARCHIVES should only print out when a .o is actually used from an archive
 		_archiveFilesLogged.insert(file);
 		const char* fullPath = file->path();
-		char realName[MAXPATHLEN];
+		char realName[PATH_MAX];
 		if ( realpath(fullPath, realName) != NULL )
 			fullPath = realName;
 		logTraceInfo("[Logging for XBS] Used static archive: %s\n", fullPath);
@@ -499,7 +500,7 @@
 		}
 	}
 
-	char trace_buffer[MAXPATHLEN * 2];
+	char trace_buffer[PATH_MAX * 2];
     va_list ap;
 	va_start(ap, format);
 	int length = vsnprintf(trace_buffer, sizeof(trace_buffer), format, ap);
@@ -940,14 +941,7 @@
 	_remainingInputFiles = files.size();
 	
 	// initialize info for parsing input files on worker threads
-	unsigned int ncpus;
-	int mib[2];
-	size_t len = sizeof(ncpus);
-	mib[0] = CTL_HW;
-	mib[1] = HW_NCPU;
-	if (sysctl(mib, 2, &ncpus, &len, NULL, 0) != 0) {
-		ncpus = 1;
-	}
+	unsigned int ncpus = 2;
 	_availableWorkers = MIN(ncpus, files.size()); // max # workers we permit
 	_idleWorkers = 0;
 	
@@ -1457,7 +1451,7 @@
 			for (ld::dylib::File* dylib :  implicitDylibs) {
 				if ( dylib->speculativelyLoaded() && !dylib->explicitlyLinked() && dylib->providedExportAtom() ) {
 					const char* fullPath = dylib->path();
-					char realName[MAXPATHLEN];
+					char realName[PATH_MAX];
 					if ( realpath(fullPath, realName) != NULL )
 						fullPath = realName;
 					logTraceInfo("[Logging for XBS] Used dynamic library: %s\n", fullPath);
diff -ur ld64-274.2-orig/src/ld/ld.cpp ld64-274.2/src/ld/ld.cpp
--- ld64-274.2-orig/src/ld/ld.cpp	2017-09-29 07:44:04.316338766 -0700
+++ ld64-274.2/src/ld/ld.cpp	2017-09-29 20:49:23.429249818 -0700
@@ -21,12 +21,6 @@
  *
  * @APPLE_LICENSE_HEADER_END@
  */
- 
-// start temp HACK for cross builds
-extern "C" double log2 ( double );
-//#define __MATH__
-// end temp HACK for cross builds
-
 
 #include <stdlib.h>
 #include <sys/types.h>
@@ -1023,10 +1017,10 @@
 		// sanity check size
 		if ( ((address + sect->size) > _options.maxAddress()) && (_options.outputKind() != Options::kObjectFile) 
 															  && (_options.outputKind() != Options::kStaticExecutable) )
-			throwf("section %s (address=0x%08llX, size=%llu) would make the output executable exceed available address range", 
+			throwf("section %s (address=0x%lX, size=%lu) would make the output executable exceed available address range", 
 						sect->sectionName(), address, sect->size);
 		
-		if ( log ) fprintf(stderr, "  address=0x%08llX, hidden=%d, alignment=%02d, section=%s,%s\n",
+		if ( log ) fprintf(stderr, "  address=0x%08lX, hidden=%d, alignment=%02d, section=%s,%s\n",
 						sect->address, sect->isSectionHidden(), sect->alignment, sect->segmentName(), sect->sectionName());
 		// update running totals
 		if ( !sect->isSectionHidden() || hiddenSectionsOccupyAddressSpace )
@@ -1057,7 +1051,7 @@
 				address = ( (unalignedAddress+alignment-1) & (-alignment) );
 				sect->alignmentPaddingBytes = (address - unalignedAddress);
 				sect->address = address;
-				if ( log ) fprintf(stderr, "  address=0x%08llX, hidden=%d, alignment=%02d, section=%s,%s\n",
+				if ( log ) fprintf(stderr, "  address=0x%08lX, hidden=%d, alignment=%02d, section=%s,%s\n",
 									sect->address, sect->isSectionHidden(), sect->alignment, sect->segmentName(), sect->sectionName());
 				// update running totals
 				if ( !sect->isSectionHidden() || hiddenSectionsOccupyAddressSpace )
@@ -1116,7 +1110,7 @@
 		// sanity check size
 		if ( ((address + sect->size) > _options.maxAddress()) && (_options.outputKind() != Options::kObjectFile) 
 															  && (_options.outputKind() != Options::kStaticExecutable) )
-				throwf("section %s (address=0x%08llX, size=%llu) would make the output executable exceed available address range", 
+				throwf("section %s (address=0x%08lX, size=%lu) would make the output executable exceed available address range", 
 						sect->sectionName(), address, sect->size);
 
 		// sanity check it does not overlap a fixed address segment
@@ -1142,7 +1136,7 @@
 			}
 		}
 		
-		if ( log ) fprintf(stderr, "  address=0x%08llX, size=0x%08llX, hidden=%d, alignment=%02d, padBytes=%d, section=%s,%s\n",
+		if ( log ) fprintf(stderr, "  address=0x%08lX, size=0x%08lX, hidden=%d, alignment=%02d, padBytes=%d, section=%s,%s\n",
 							sect->address, sect->size, sect->isSectionHidden(), sect->alignment, sect->alignmentPaddingBytes, 
 							sect->segmentName(), sect->sectionName());
 		// update running totals
@@ -1156,7 +1150,7 @@
 			ld::Internal::FinalSection* sect = *it;
 			//if ( sect->isSectionHidden() )
 			//	continue;
-			fprintf(stderr, "  address:0x%08llX, alignment:2^%d, size:0x%08llX, padBytes:%d, section:%s/%s\n",
+			fprintf(stderr, "  address:0x%08lX, alignment:2^%d, size:0x%08lX, padBytes:%d, section:%s/%s\n",
 							sect->address, sect->alignment, sect->size, sect->alignmentPaddingBytes, 
 							sect->segmentName(), sect->sectionName());
 	
@@ -1197,7 +1191,7 @@
 			fileOffset += sect->size;
 		}
 		
-		if ( log ) fprintf(stderr, "  fileoffset=0x%08llX, address=0x%08llX, hidden=%d, size=%lld, alignment=%02d, section=%s,%s\n",
+		if ( log ) fprintf(stderr, "  fileoffset=0x%08lX, address=0x%08lX, hidden=%d, size=%ld, alignment=%02d, section=%s,%s\n",
 				sect->fileOffset, sect->address, sect->isSectionHidden(), sect->size, sect->alignment, 
 				sect->segmentName(), sect->sectionName());
 	}
@@ -1223,7 +1217,7 @@
 {
 	char* result = out;
 	char rawNum[30];
-	sprintf(rawNum, "%llu", in);
+	sprintf(rawNum, "%lu", in);
 	const int rawNumLen = strlen(rawNum);
 	for(int i=0; i < rawNumLen-1; ++i) {
 		*out++ = rawNum[i];
diff -ur ld64-274.2-orig/src/ld/Options.cpp ld64-274.2/src/ld/Options.cpp
--- ld64-274.2-orig/src/ld/Options.cpp	2017-09-29 07:44:04.319672117 -0700
+++ ld64-274.2/src/ld/Options.cpp	2017-10-20 21:42:54.069243537 -0700
@@ -35,6 +35,8 @@
 #include <cxxabi.h>
 #include <Availability.h>
 #include <tapi/tapi.h>
+#include <stdarg.h>
+#include <limits.h>
 
 #include <vector>
 #include <map>
@@ -1200,7 +1202,7 @@
 std::vector<const char*> Options::SetWithWildcards::data() const
 {
 	std::vector<const char*> data;
-	for (NameSet::iterator it=regularBegin(); it != regularEnd(); ++it) {
+	for (NameSet::const_iterator it=regularBegin(); it != regularEnd(); ++it) {
 		data.push_back(*it);
 	}
 	for (std::vector<const char*>::const_iterator it=fWildCard.begin(); it != fWildCard.end(); ++it) {
@@ -2562,7 +2564,7 @@
 				fBaseAddress = parseAddress(address);
 				uint64_t temp = ((fBaseAddress+fSegmentAlignment-1) & (-fSegmentAlignment)); 
 				if ( fBaseAddress != temp ) {
-					warning("-seg1addr not %lld byte aligned, rounding up", fSegmentAlignment);
+					warning("-seg1addr not %ld byte aligned, rounding up", fSegmentAlignment);
 					fBaseAddress = temp;
 				}
 				cannotBeUsedWithBitcode(arg);
@@ -2826,7 +2828,7 @@
 				seg.address = parseAddress(argv[++i]);
 				uint64_t temp = ((seg.address+fSegmentAlignment-1) & (-fSegmentAlignment)); 
 				if ( seg.address != temp )
-					warning("-segaddr %s not %lld byte aligned", seg.name, fSegmentAlignment);
+					warning("-segaddr %s not %ld byte aligned", seg.name, fSegmentAlignment);
 				fCustomSegmentAddresses.push_back(seg);
 				cannotBeUsedWithBitcode(arg);
 			}
@@ -4501,7 +4503,7 @@
 			}
 			// range check -seg1addr for ARM
 			if ( fBaseAddress > fMaxAddress ) {
-				warning("ignoring -seg1addr 0x%08llX.  Address out of range.", fBaseAddress);
+				warning("ignoring -seg1addr 0x%08lX.  Address out of range.", fBaseAddress);
 				fBaseAddress = 0;
 			}
 			break;
@@ -5130,7 +5132,7 @@
 	// Make sure -image_base matches alignment
 	uint64_t alignedBaseAddress = (fBaseAddress+fSegmentAlignment-1) & (-fSegmentAlignment);
 	if ( alignedBaseAddress != fBaseAddress ) {
-		warning("base address 0x%llX is not properly aligned. Changing it to 0x%llX", fBaseAddress, alignedBaseAddress);
+		warning("base address 0x%lX is not properly aligned. Changing it to 0x%lX", fBaseAddress, alignedBaseAddress);
 		fBaseAddress = alignedBaseAddress;
 	}
 
@@ -5324,7 +5326,7 @@
 				break;
 		}
 		if ( (fStackSize & (-fSegmentAlignment)) != fStackSize )
-			throwf("-stack_size must be multiple of segment alignment (%lldKB)", fSegmentAlignment/1024);
+			throwf("-stack_size must be multiple of segment alignment (%ldKB)", fSegmentAlignment/1024);
 		switch ( fOutputKind ) {
 			case Options::kDynamicExecutable:
 			case Options::kStaticExecutable:
@@ -5339,7 +5341,7 @@
 				throw "-stack_size option can only be used when linking a main executable";
 		}
 		if ( fStackSize > fStackAddr )
-			throwf("-stack_size (0x%08llX) must be smaller than -stack_addr (0x%08llX)", fStackSize, fStackAddr);
+			throwf("-stack_size (0x%08lX) must be smaller than -stack_addr (0x%08lX)", fStackSize, fStackAddr);
 	}
 
 	// check that -allow_stack_execute is only used with main executables
@@ -5439,7 +5441,7 @@
 
 	// make sure all required exported symbols exist
 	std::vector<const char*> impliedExports;
-	for (NameSet::iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
 		const char* name = *it;
 		const int len = strlen(name);
 		if ( (strcmp(&name[len-3], ".eh") == 0) || (strncmp(name, ".objc_category_name_", 20) == 0) ) {
@@ -5471,7 +5473,7 @@
 	}
 
 	// make sure all required re-exported symbols exist
-	for (NameSet::iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
 		fInitialUndefines.push_back(*it);
 	}
 	
@@ -5505,7 +5507,7 @@
 		if ( fZeroPageSize != ULLONG_MAX ) {
 			for (std::vector<SegmentStart>::iterator it = fCustomSegmentAddresses.begin(); it != fCustomSegmentAddresses.end(); ++it) {
 				if ( it->address < fZeroPageSize )
-					throwf("-segaddr %s 0x%llX conflicts with -pagezero_size", it->name, it->address);
+					throwf("-segaddr %s 0x%lX conflicts with -pagezero_size", it->name, it->address);
 			}
 		}
 		// verify no duplicates
diff -ur ld64-274.2-orig/src/ld/Options.h ld64-274.2/src/ld/Options.h
--- ld64-274.2-orig/src/ld/Options.h	2017-09-29 07:44:04.319672117 -0700
+++ ld64-274.2/src/ld/Options.h	2017-09-29 20:37:11.961284911 -0700
@@ -502,8 +502,9 @@
 		bool					containsNonWildcard(const char*) const;
 		bool					empty() const			{ return fRegular.empty() && fWildCard.empty(); }
 		bool					hasWildCards() const	{ return !fWildCard.empty(); }
-		NameSet::iterator		regularBegin() const	{ return fRegular.begin(); }
-		NameSet::iterator		regularEnd() const		{ return fRegular.end(); }
+		// thanks to tpoechtrager's cctools-port for this fix
+		NameSet::const_iterator	regularBegin() const	{ return fRegular.begin(); }
+		NameSet::const_iterator	regularEnd() const		{ return fRegular.end(); }
 		void					remove(const NameSet&); 
 		std::vector<const char*>		data() const;
 	private:
diff -ur ld64-274.2-orig/src/ld/Snapshot.h ld64-274.2/src/ld/Snapshot.h
--- ld64-274.2-orig/src/ld/Snapshot.h	2017-09-29 07:44:04.319672117 -0700
+++ ld64-274.2/src/ld/Snapshot.h	2017-09-29 20:32:25.044874041 -0700
@@ -88,7 +88,6 @@
 
     friend class SnapshotArchiveFileLog;
     
-    typedef std::vector<void(^)(void)> SnapshotLog;    
 
     struct strcompclass {
         bool operator() (const char *a, const char *b) const { return ::strcmp(a, b) < 0; }
@@ -128,7 +127,6 @@
     void addFrameworkArg(const char *framework);
     void addDylibArg(const char *dylib);
 
-    SnapshotLog fLog;           // log of events that recorded data in a snapshot prior to createSnapshot()
     bool fRecordArgs;           // record command line 
     bool fRecordObjects;        // record .o files 
     bool fRecordDylibSymbols;   // record referenced dylib/framework symbols
