diff -ur ld64-274.2-orig/src/ld/InputFiles.cpp ld64-274.2/src/ld/InputFiles.cpp
--- ld64-274.2-orig/src/ld/InputFiles.cpp	2017-09-29 07:44:04.316338766 -0700
+++ ld64-274.2/src/ld/InputFiles.cpp	2017-10-23 20:17:14.320471795 -0700
@@ -29,6 +29,7 @@
 #include <sys/stat.h>
 #include <sys/mman.h>
 #include <sys/sysctl.h>
+#include <sys/param.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <limits.h>
@@ -215,7 +216,7 @@
 	if ( fd == -1 )
 		throwf("can't open file, errno=%d", errno);
 	if ( info.fileLen < 20 )
-		throwf("file too small (length=%llu)", info.fileLen);
+		throwf("file too small (length=%lu)", info.fileLen);
 
 	uint8_t* p = (uint8_t*)::mmap(NULL, info.fileLen, PROT_READ, MAP_FILE | MAP_PRIVATE, fd, 0);
 	if ( p == (uint8_t*)(-1) )
@@ -264,7 +265,7 @@
 					newFileLen = statBuffer.st_size;
 				}
 				if ( fileOffset+len > newFileLen ) {
-					throwf("truncated fat file. Slice from %u to %llu is past end of file with length %llu", 
+					throwf("truncated fat file. Slice from %u to %lu is past end of file with length %lu", 
 						fileOffset, fileOffset+len, info.fileLen);
 				}
 			}
@@ -422,7 +423,7 @@
 {
 	if ( _options.traceDylibs() ) {
 		const char* fullPath = file->path();
-		char realName[MAXPATHLEN];
+		char realName[PATH_MAX];
 		if ( realpath(fullPath, realName) != NULL )
 			fullPath = realName;
 		const ld::dylib::File* dylib = dynamic_cast<const ld::dylib::File*>(file);
@@ -472,7 +473,7 @@
 		// <rdar://problem/4947347> LD_TRACE_ARCHIVES should only print out when a .o is actually used from an archive
 		_archiveFilesLogged.insert(file);
 		const char* fullPath = file->path();
-		char realName[MAXPATHLEN];
+		char realName[PATH_MAX];
 		if ( realpath(fullPath, realName) != NULL )
 			fullPath = realName;
 		logTraceInfo("[Logging for XBS] Used static archive: %s\n", fullPath);
@@ -499,7 +500,7 @@
 		}
 	}
 
-	char trace_buffer[MAXPATHLEN * 2];
+	char trace_buffer[PATH_MAX * 2];
     va_list ap;
 	va_start(ap, format);
 	int length = vsnprintf(trace_buffer, sizeof(trace_buffer), format, ap);
@@ -940,13 +941,10 @@
 	_remainingInputFiles = files.size();
 	
 	// initialize info for parsing input files on worker threads
-	unsigned int ncpus;
-	int mib[2];
-	size_t len = sizeof(ncpus);
-	mib[0] = CTL_HW;
-	mib[1] = HW_NCPU;
-	if (sysctl(mib, 2, &ncpus, &len, NULL, 0) != 0) {
-		ncpus = 1;
+	unsigned int ncpus = 2;
+	{
+		long ret = sysconf(_SC_NPROCESSORS_ONLN);
+		if (ret > 0) { ncpus = ret; }
 	}
 	_availableWorkers = MIN(ncpus, files.size()); // max # workers we permit
 	_idleWorkers = 0;
@@ -1457,7 +1455,7 @@
 			for (ld::dylib::File* dylib :  implicitDylibs) {
 				if ( dylib->speculativelyLoaded() && !dylib->explicitlyLinked() && dylib->providedExportAtom() ) {
 					const char* fullPath = dylib->path();
-					char realName[MAXPATHLEN];
+					char realName[PATH_MAX];
 					if ( realpath(fullPath, realName) != NULL )
 						fullPath = realName;
 					logTraceInfo("[Logging for XBS] Used dynamic library: %s\n", fullPath);
diff -ur ld64-274.2-orig/src/ld/ld.cpp ld64-274.2/src/ld/ld.cpp
--- ld64-274.2-orig/src/ld/ld.cpp	2017-09-29 07:44:04.316338766 -0700
+++ ld64-274.2/src/ld/ld.cpp	2017-09-29 20:49:23.429249818 -0700
@@ -21,12 +21,6 @@
  *
  * @APPLE_LICENSE_HEADER_END@
  */
- 
-// start temp HACK for cross builds
-extern "C" double log2 ( double );
-//#define __MATH__
-// end temp HACK for cross builds
-
 
 #include <stdlib.h>
 #include <sys/types.h>
@@ -1023,10 +1017,10 @@
 		// sanity check size
 		if ( ((address + sect->size) > _options.maxAddress()) && (_options.outputKind() != Options::kObjectFile) 
 															  && (_options.outputKind() != Options::kStaticExecutable) )
-			throwf("section %s (address=0x%08llX, size=%llu) would make the output executable exceed available address range", 
+			throwf("section %s (address=0x%lX, size=%lu) would make the output executable exceed available address range", 
 						sect->sectionName(), address, sect->size);
 		
-		if ( log ) fprintf(stderr, "  address=0x%08llX, hidden=%d, alignment=%02d, section=%s,%s\n",
+		if ( log ) fprintf(stderr, "  address=0x%08lX, hidden=%d, alignment=%02d, section=%s,%s\n",
 						sect->address, sect->isSectionHidden(), sect->alignment, sect->segmentName(), sect->sectionName());
 		// update running totals
 		if ( !sect->isSectionHidden() || hiddenSectionsOccupyAddressSpace )
@@ -1057,7 +1051,7 @@
 				address = ( (unalignedAddress+alignment-1) & (-alignment) );
 				sect->alignmentPaddingBytes = (address - unalignedAddress);
 				sect->address = address;
-				if ( log ) fprintf(stderr, "  address=0x%08llX, hidden=%d, alignment=%02d, section=%s,%s\n",
+				if ( log ) fprintf(stderr, "  address=0x%08lX, hidden=%d, alignment=%02d, section=%s,%s\n",
 									sect->address, sect->isSectionHidden(), sect->alignment, sect->segmentName(), sect->sectionName());
 				// update running totals
 				if ( !sect->isSectionHidden() || hiddenSectionsOccupyAddressSpace )
@@ -1116,7 +1110,7 @@
 		// sanity check size
 		if ( ((address + sect->size) > _options.maxAddress()) && (_options.outputKind() != Options::kObjectFile) 
 															  && (_options.outputKind() != Options::kStaticExecutable) )
-				throwf("section %s (address=0x%08llX, size=%llu) would make the output executable exceed available address range", 
+				throwf("section %s (address=0x%08lX, size=%lu) would make the output executable exceed available address range", 
 						sect->sectionName(), address, sect->size);
 
 		// sanity check it does not overlap a fixed address segment
@@ -1142,7 +1136,7 @@
 			}
 		}
 		
-		if ( log ) fprintf(stderr, "  address=0x%08llX, size=0x%08llX, hidden=%d, alignment=%02d, padBytes=%d, section=%s,%s\n",
+		if ( log ) fprintf(stderr, "  address=0x%08lX, size=0x%08lX, hidden=%d, alignment=%02d, padBytes=%d, section=%s,%s\n",
 							sect->address, sect->size, sect->isSectionHidden(), sect->alignment, sect->alignmentPaddingBytes, 
 							sect->segmentName(), sect->sectionName());
 		// update running totals
@@ -1156,7 +1150,7 @@
 			ld::Internal::FinalSection* sect = *it;
 			//if ( sect->isSectionHidden() )
 			//	continue;
-			fprintf(stderr, "  address:0x%08llX, alignment:2^%d, size:0x%08llX, padBytes:%d, section:%s/%s\n",
+			fprintf(stderr, "  address:0x%08lX, alignment:2^%d, size:0x%08lX, padBytes:%d, section:%s/%s\n",
 							sect->address, sect->alignment, sect->size, sect->alignmentPaddingBytes, 
 							sect->segmentName(), sect->sectionName());
 	
@@ -1197,7 +1191,7 @@
 			fileOffset += sect->size;
 		}
 		
-		if ( log ) fprintf(stderr, "  fileoffset=0x%08llX, address=0x%08llX, hidden=%d, size=%lld, alignment=%02d, section=%s,%s\n",
+		if ( log ) fprintf(stderr, "  fileoffset=0x%08lX, address=0x%08lX, hidden=%d, size=%ld, alignment=%02d, section=%s,%s\n",
 				sect->fileOffset, sect->address, sect->isSectionHidden(), sect->size, sect->alignment, 
 				sect->segmentName(), sect->sectionName());
 	}
@@ -1223,7 +1217,7 @@
 {
 	char* result = out;
 	char rawNum[30];
-	sprintf(rawNum, "%llu", in);
+	sprintf(rawNum, "%lu", in);
 	const int rawNumLen = strlen(rawNum);
 	for(int i=0; i < rawNumLen-1; ++i) {
 		*out++ = rawNum[i];
diff -ur ld64-274.2-orig/src/ld/LinkEdit.hpp ld64-274.2/src/ld/LinkEdit.hpp
--- ld64-274.2-orig/src/ld/LinkEdit.hpp	2017-09-29 07:44:04.316338766 -0700
+++ ld64-274.2/src/ld/LinkEdit.hpp	2017-10-24 08:53:55.121187591 -0700
@@ -324,39 +324,39 @@
 				done = true;
 				break;
 			case REBASE_OPCODE_SET_TYPE_IMM:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_SET_TYPE_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_SET_TYPE_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_SET_TYPE_IMM | it->operand1);
 				break;
 			case REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%lld, 0x%llX)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%ld, 0x%lX)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB | it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 			case REBASE_OPCODE_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case REBASE_OPCODE_ADD_ADDR_IMM_SCALED:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_ADD_ADDR_IMM_SCALED(%lld=0x%llX)\n", it->operand1, it->operand1*sizeof(pint_t));
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_ADD_ADDR_IMM_SCALED(%ld=0x%lX)\n", it->operand1, it->operand1*sizeof(pint_t));
 				this->_encodedData.append_byte(REBASE_OPCODE_ADD_ADDR_IMM_SCALED | it->operand1 );
 				break;
 			case REBASE_OPCODE_DO_REBASE_IMM_TIMES:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_IMM_TIMES(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_IMM_TIMES(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_DO_REBASE_IMM_TIMES | it->operand1);
 				break;
 			case REBASE_OPCODE_DO_REBASE_ULEB_TIMES:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_DO_REBASE_ULEB_TIMES);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:
-				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB(%lld, %lld)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB(%ld, %ld)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
@@ -534,16 +534,16 @@
 				done = true;
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_SPECIAL_IMM | (it->operand1 & BIND_IMMEDIATE_MASK));
 				break;
 			case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:
@@ -552,21 +552,21 @@
 				this->_encodedData.append_string(it->name);
 				break;
 			case BIND_OPCODE_SET_TYPE_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_TYPE_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_ADDEND_SLEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_ADDEND_SLEB);
 				this->_encodedData.append_sleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%lld, 0x%llX)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%ld, 0x%lX)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB | it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 			case BIND_OPCODE_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
@@ -575,16 +575,16 @@
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%lld=0x%llX)\n", it->operand1, it->operand1*sizeof(pint_t));
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%ld=0x%lX)\n", it->operand1, it->operand1*sizeof(pint_t));
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED | it->operand1 );
 				break;
 			case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%lld, %lld)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%ld, %ld)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
@@ -772,16 +772,16 @@
 				done = true;
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_DYLIB_SPECIAL_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_DYLIB_SPECIAL_IMM | (it->operand1 & BIND_IMMEDIATE_MASK));
 				break;
 			case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:
@@ -790,21 +790,21 @@
 				this->_encodedData.append_string(it->name);
 				break;
 			case BIND_OPCODE_SET_TYPE_IMM:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_TYPE_IMM(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_TYPE_IMM | it->operand1);
 				break;
 			case BIND_OPCODE_SET_ADDEND_SLEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%lld)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_ADDEND_SLEB(%ld)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_ADDEND_SLEB);
 				this->_encodedData.append_sleb128(it->operand1);
 				break;
 			case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%lld, 0x%llX)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB(%ld, 0x%lX)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB | it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
 				break;
 			case BIND_OPCODE_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
@@ -813,16 +813,16 @@
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%llX)\n", it->operand1);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB(0x%lX)\n", it->operand1);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				break;
 			case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%lld=0x%llX)\n", it->operand1, it->operand1*sizeof(pint_t));
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED(%ld=0x%lX)\n", it->operand1, it->operand1*sizeof(pint_t));
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED | it->operand1 );
 				break;
 			case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
-				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%lld, %lld)\n", it->operand1, it->operand2);
+				if ( log ) fprintf(stderr, "BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB(%ld, %ld)\n", it->operand1, it->operand2);
 				this->_encodedData.append_byte(BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB);
 				this->_encodedData.append_uleb128(it->operand1);
 				this->_encodedData.append_uleb128(it->operand2);
@@ -1018,7 +1018,7 @@
 				entry.importName = atom->name();
 			}
 			entries.push_back(entry);
-			//fprintf(stderr, "re-export %s from lib %llu as %s\n", entry.importName, entry.other, entry.name);
+			//fprintf(stderr, "re-export %s from lib %lu as %s\n", entry.importName, entry.other, entry.name);
 		}
 		else if ( atom->definition() == ld::Atom::definitionAbsolute ) {
 			entry.name = atom->name();
@@ -1136,7 +1136,7 @@
 			_64bitPointerLocations.push_back(address);
 			break;
 		default:
-			warning("codegen at address 0x%08llX prevents image from working in dyld shared cache", address);
+			warning("codegen at address 0x%08lX prevents image from working in dyld shared cache", address);
 			break;
 	}
 }
@@ -1152,7 +1152,7 @@
 			_32bitPointerLocations.push_back(address);
 			break;
 		default:
-			warning("codegen at address 0x%08llX prevents image from working in dyld shared cache", address);
+			warning("codegen at address 0x%08lX prevents image from working in dyld shared cache", address);
 			break;
 	}
 }
@@ -1179,7 +1179,7 @@
 			_thumbHi16Locations[extra].push_back(address);
 			break;
 		default:
-			warning("codegen at address 0x%08llX prevents image from working in dyld shared cache", address);
+			warning("codegen at address 0x%08lX prevents image from working in dyld shared cache", address);
 			break;
 	}
 }
@@ -1207,7 +1207,7 @@
 			_64bitPointerLocations.push_back(address);
 			break;
 		default:
-			warning("codegen at address 0x%08llX prevents image from working in dyld shared cache", address);
+			warning("codegen at address 0x%08lX prevents image from working in dyld shared cache", address);
 			break;
 	}
 }
diff -ur ld64-274.2-orig/src/ld/Options.cpp ld64-274.2/src/ld/Options.cpp
--- ld64-274.2-orig/src/ld/Options.cpp	2017-09-29 07:44:04.319672117 -0700
+++ ld64-274.2/src/ld/Options.cpp	2017-10-20 21:42:54.069243537 -0700
@@ -35,6 +35,8 @@
 #include <cxxabi.h>
 #include <Availability.h>
 #include <tapi/tapi.h>
+#include <stdarg.h>
+#include <limits.h>
 
 #include <vector>
 #include <map>
@@ -1200,7 +1202,7 @@
 std::vector<const char*> Options::SetWithWildcards::data() const
 {
 	std::vector<const char*> data;
-	for (NameSet::iterator it=regularBegin(); it != regularEnd(); ++it) {
+	for (NameSet::const_iterator it=regularBegin(); it != regularEnd(); ++it) {
 		data.push_back(*it);
 	}
 	for (std::vector<const char*>::const_iterator it=fWildCard.begin(); it != fWildCard.end(); ++it) {
@@ -2562,7 +2564,7 @@
 				fBaseAddress = parseAddress(address);
 				uint64_t temp = ((fBaseAddress+fSegmentAlignment-1) & (-fSegmentAlignment)); 
 				if ( fBaseAddress != temp ) {
-					warning("-seg1addr not %lld byte aligned, rounding up", fSegmentAlignment);
+					warning("-seg1addr not %ld byte aligned, rounding up", fSegmentAlignment);
 					fBaseAddress = temp;
 				}
 				cannotBeUsedWithBitcode(arg);
@@ -2826,7 +2828,7 @@
 				seg.address = parseAddress(argv[++i]);
 				uint64_t temp = ((seg.address+fSegmentAlignment-1) & (-fSegmentAlignment)); 
 				if ( seg.address != temp )
-					warning("-segaddr %s not %lld byte aligned", seg.name, fSegmentAlignment);
+					warning("-segaddr %s not %ld byte aligned", seg.name, fSegmentAlignment);
 				fCustomSegmentAddresses.push_back(seg);
 				cannotBeUsedWithBitcode(arg);
 			}
@@ -4501,7 +4503,7 @@
 			}
 			// range check -seg1addr for ARM
 			if ( fBaseAddress > fMaxAddress ) {
-				warning("ignoring -seg1addr 0x%08llX.  Address out of range.", fBaseAddress);
+				warning("ignoring -seg1addr 0x%08lX.  Address out of range.", fBaseAddress);
 				fBaseAddress = 0;
 			}
 			break;
@@ -5130,7 +5132,7 @@
 	// Make sure -image_base matches alignment
 	uint64_t alignedBaseAddress = (fBaseAddress+fSegmentAlignment-1) & (-fSegmentAlignment);
 	if ( alignedBaseAddress != fBaseAddress ) {
-		warning("base address 0x%llX is not properly aligned. Changing it to 0x%llX", fBaseAddress, alignedBaseAddress);
+		warning("base address 0x%lX is not properly aligned. Changing it to 0x%lX", fBaseAddress, alignedBaseAddress);
 		fBaseAddress = alignedBaseAddress;
 	}
 
@@ -5324,7 +5326,7 @@
 				break;
 		}
 		if ( (fStackSize & (-fSegmentAlignment)) != fStackSize )
-			throwf("-stack_size must be multiple of segment alignment (%lldKB)", fSegmentAlignment/1024);
+			throwf("-stack_size must be multiple of segment alignment (%ldKB)", fSegmentAlignment/1024);
 		switch ( fOutputKind ) {
 			case Options::kDynamicExecutable:
 			case Options::kStaticExecutable:
@@ -5339,7 +5341,7 @@
 				throw "-stack_size option can only be used when linking a main executable";
 		}
 		if ( fStackSize > fStackAddr )
-			throwf("-stack_size (0x%08llX) must be smaller than -stack_addr (0x%08llX)", fStackSize, fStackAddr);
+			throwf("-stack_size (0x%08lX) must be smaller than -stack_addr (0x%08lX)", fStackSize, fStackAddr);
 	}
 
 	// check that -allow_stack_execute is only used with main executables
@@ -5439,7 +5441,7 @@
 
 	// make sure all required exported symbols exist
 	std::vector<const char*> impliedExports;
-	for (NameSet::iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
 		const char* name = *it;
 		const int len = strlen(name);
 		if ( (strcmp(&name[len-3], ".eh") == 0) || (strncmp(name, ".objc_category_name_", 20) == 0) ) {
@@ -5471,7 +5473,7 @@
 	}
 
 	// make sure all required re-exported symbols exist
-	for (NameSet::iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
 		fInitialUndefines.push_back(*it);
 	}
 	
@@ -5505,7 +5507,7 @@
 		if ( fZeroPageSize != ULLONG_MAX ) {
 			for (std::vector<SegmentStart>::iterator it = fCustomSegmentAddresses.begin(); it != fCustomSegmentAddresses.end(); ++it) {
 				if ( it->address < fZeroPageSize )
-					throwf("-segaddr %s 0x%llX conflicts with -pagezero_size", it->name, it->address);
+					throwf("-segaddr %s 0x%lX conflicts with -pagezero_size", it->name, it->address);
 			}
 		}
 		// verify no duplicates
diff -ur ld64-274.2-orig/src/ld/Options.h ld64-274.2/src/ld/Options.h
--- ld64-274.2-orig/src/ld/Options.h	2017-09-29 07:44:04.319672117 -0700
+++ ld64-274.2/src/ld/Options.h	2017-09-29 20:37:11.961284911 -0700
@@ -502,8 +502,9 @@
 		bool					containsNonWildcard(const char*) const;
 		bool					empty() const			{ return fRegular.empty() && fWildCard.empty(); }
 		bool					hasWildCards() const	{ return !fWildCard.empty(); }
-		NameSet::iterator		regularBegin() const	{ return fRegular.begin(); }
-		NameSet::iterator		regularEnd() const		{ return fRegular.end(); }
+		// thanks to tpoechtrager's cctools-port for this fix
+		NameSet::const_iterator	regularBegin() const	{ return fRegular.begin(); }
+		NameSet::const_iterator	regularEnd() const		{ return fRegular.end(); }
 		void					remove(const NameSet&); 
 		std::vector<const char*>		data() const;
 	private:
diff -ur ld64-274.2-orig/src/ld/OutputFile.cpp ld64-274.2/src/ld/OutputFile.cpp
--- ld64-274.2-orig/src/ld/OutputFile.cpp	2017-09-29 07:44:04.319672117 -0700
+++ ld64-274.2/src/ld/OutputFile.cpp	2017-10-24 08:57:57.297185692 -0700
@@ -129,13 +129,13 @@
 {
 	fprintf(stderr, "SORTED:\n");
 	for (std::vector<ld::Internal::FinalSection*>::iterator it = state.sections.begin(); it != state.sections.end(); ++it) {
-		fprintf(stderr, "final section %p %s/%s %s start addr=0x%08llX, size=0x%08llX, alignment=%02d, fileOffset=0x%08llX\n", 
+		fprintf(stderr, "final section %p %s/%s %s start addr=0x%08lX, size=0x%08lX, alignment=%02d, fileOffset=0x%08lX\n", 
 				(*it), (*it)->segmentName(), (*it)->sectionName(), (*it)->isSectionHidden() ? "(hidden)" : "", 
 				(*it)->address, (*it)->size, (*it)->alignment, (*it)->fileOffset);
 		if ( printAtoms ) {
 			std::vector<const ld::Atom*>& atoms = (*it)->atoms;
 			for (std::vector<const ld::Atom*>::iterator ait = atoms.begin(); ait != atoms.end(); ++ait) {
-				fprintf(stderr, "   %p (0x%04llX) %s\n", *ait, (*ait)->size(), (*ait)->name());
+				fprintf(stderr, "   %p (0x%04lX) %s\n", *ait, (*ait)->size(), (*ait)->name());
 			}
 		}
 	}
@@ -216,7 +216,7 @@
 					break;
 				default:
 					(const_cast<ld::Atom*>(atom))->setSectionStartAddress(sect->address);
-					if ( log ) fprintf(stderr, "    atom=%p, addr=0x%08llX, name=%s\n", atom, atom->finalAddress(), atom->name());
+					if ( log ) fprintf(stderr, "    atom=%p, addr=0x%08lX, name=%s\n", atom, atom->finalAddress(), atom->name());
 					break;
 			}
 		}
@@ -432,7 +432,7 @@
 	switch ( atom.symbolTableInclusion() ) {
 		case ld::Atom::symbolTableNotIn:
 		case ld::Atom::symbolTableNotInFinalLinkedImages:
-			sprintf(buffer, "%s@0x%08llX", atom.name(), atom.objectAddress());
+			sprintf(buffer, "%s@0x%08lX", atom.name(), atom.objectAddress());
 			break;
 		case ld::Atom::symbolTableIn:
 		case ld::Atom::symbolTableInAndNeverStrip:
@@ -595,7 +595,7 @@
 	for (std::vector<ld::Internal::FinalSection*>::iterator it = state.sections.begin(); it != state.sections.end(); ++it) {
 		if ( (*it)->isSectionHidden() )
 			continue;
-		fprintf(stderr, "    %s/%s addr=0x%08llX, size=0x%08llX, fileOffset=0x%08llX, type=%d\n", 
+		fprintf(stderr, "    %s/%s addr=0x%08lX, size=0x%08lX, fileOffset=0x%08lX, type=%d\n", 
 				(*it)->segmentName(), (*it)->sectionName(), 
 				(*it)->address, (*it)->size, (*it)->fileOffset, (*it)->type());
 	}
@@ -609,7 +609,7 @@
 		printSectionLayout(state);
 		
 		const ld::Atom* target;	
-		throwf("8-bit reference out of range (%lld max is +/-127B): from %s (0x%08llX) to %s (0x%08llX)", 
+		throwf("8-bit reference out of range (%ld max is +/-127B): from %s (0x%08lX) to %s (0x%08lX)", 
 				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 				addressOf(state, fixup, &target));
 	}
@@ -623,7 +623,7 @@
 		printSectionLayout(state);
 		
 		const ld::Atom* target;	
-		throwf("16-bit reference out of range (%lld max is +/-32KB): from %s (0x%08llX) to %s (0x%08llX)", 
+		throwf("16-bit reference out of range (%ld max is +/-32KB): from %s (0x%08lX) to %s (0x%08lX)", 
 				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup),  
 				addressOf(state, fixup, &target));
 	}
@@ -637,7 +637,7 @@
 		printSectionLayout(state);
 		
 		const ld::Atom* target;	
-		throwf("32-bit branch out of range (%lld max is +/-2GB): from %s (0x%08llX) to %s (0x%08llX)",
+		throwf("32-bit branch out of range (%ld max is +/-2GB): from %s (0x%08lX) to %s (0x%08lX)",
 				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 				addressOf(state, fixup, &target));
 	}
@@ -656,7 +656,7 @@
 		if ( (_options.architecture() == CPU_TYPE_ARM) || (_options.architecture() == CPU_TYPE_I386) ) {
 			// Unlikely userland code does funky stuff like this, so warn for them, but not warn for -preload or -static
 			if ( (_options.outputKind() != Options::kPreload) && (_options.outputKind() != Options::kStaticExecutable) ) {
-				warning("32-bit absolute address out of range (0x%08llX max is 4GB): from %s + 0x%08X (0x%08llX) to 0x%08llX", 
+				warning("32-bit absolute address out of range (0x%08lX max is 4GB): from %s + 0x%08X (0x%08lX) to 0x%08lX", 
 						displacement, atom->name(), fixup->offsetInAtom, atom->finalAddress(), displacement);
 			}
 			return;
@@ -666,10 +666,10 @@
 		
 		const ld::Atom* target;	
 		if ( fixup->binding == ld::Fixup::bindingNone )
-			throwf("32-bit absolute address out of range (0x%08llX max is 4GB): from %s + 0x%08X (0x%08llX) to 0x%08llX", 
+			throwf("32-bit absolute address out of range (0x%08lX max is 4GB): from %s + 0x%08X (0x%08lX) to 0x%08lX", 
 				displacement, atom->name(), fixup->offsetInAtom, atom->finalAddress(), displacement);
 		else
-			throwf("32-bit absolute address out of range (0x%08llX max is 4GB): from %s + 0x%08X (0x%08llX) to %s (0x%08llX)", 
+			throwf("32-bit absolute address out of range (0x%08lX max is 4GB): from %s + 0x%08X (0x%08lX) to %s (0x%08lX)", 
 				displacement, atom->name(), fixup->offsetInAtom, atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 				addressOf(state, fixup, &target));
 	}
@@ -684,7 +684,7 @@
 		printSectionLayout(state);
 		
 		const ld::Atom* target;	
-		throwf("32-bit RIP relative reference out of range (%lld max is +/-4GB): from %s (0x%08llX) to %s (0x%08llX)", 
+		throwf("32-bit RIP relative reference out of range (%ld max is +/-4GB): from %s (0x%08lX) to %s (0x%08lX)", 
 				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 				addressOf(state, fixup, &target));
 	}
@@ -697,7 +697,7 @@
 		printSectionLayout(state);
 		
 		const ld::Atom* target;	
-		throwf("ARM ldr 12-bit displacement out of range (%lld max is +/-4096B): from %s (0x%08llX) to %s (0x%08llX)", 
+		throwf("ARM ldr 12-bit displacement out of range (%ld max is +/-4096B): from %s (0x%08lX) to %s (0x%08lX)", 
 				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 				addressOf(state, fixup, &target));
 	}
@@ -717,7 +717,7 @@
 	printSectionLayout(state);
 	
 	const ld::Atom* target;	
-	throwf("b/bl/blx ARM branch out of range (%lld max is +/-32MB): from %s (0x%08llX) to %s (0x%08llX)", 
+	throwf("b/bl/blx ARM branch out of range (%ld max is +/-32MB): from %s (0x%08lX) to %s (0x%08lX)", 
 			displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 			addressOf(state, fixup, &target));
 }
@@ -749,12 +749,12 @@
 
 	const ld::Atom* target;	
 	if ( _options.preferSubArchitecture() && _options.archSupportsThumb2() ) {
-		throwf("b/bl/blx thumb2 branch out of range (%lld max is +/-16MB): from %s (0x%08llX) to %s (0x%08llX)", 
+		throwf("b/bl/blx thumb2 branch out of range (%ld max is +/-16MB): from %s (0x%08lX) to %s (0x%08lX)", 
 				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 				addressOf(state, fixup, &target));
 	}
 	else {
-		throwf("b/bl/blx thumb1 branch out of range (%lld max is +/-4MB): from %s (0x%08llX) to %s (0x%08llX)", 
+		throwf("b/bl/blx thumb1 branch out of range (%ld max is +/-4MB): from %s (0x%08lX) to %s (0x%08lX)", 
 				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 				addressOf(state, fixup, &target));
 	}
@@ -769,7 +769,7 @@
 		printSectionLayout(state);
 		
 		const ld::Atom* target;	
-		throwf("b(l) ARM64 branch out of range (%lld max is +/-128MB): from %s (0x%08llX) to %s (0x%08llX)", 
+		throwf("b(l) ARM64 branch out of range (%ld max is +/-128MB): from %s (0x%08lX) to %s (0x%08lX)", 
 				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 				addressOf(state, fixup, &target));
 	}
@@ -783,7 +783,7 @@
 		printSectionLayout(state);
 		
 		const ld::Atom* target;	
-		throwf("ARM64 ADRP out of range (%lld max is +/-4GB): from %s (0x%08llX) to %s (0x%08llX)", 
+		throwf("ARM64 ADRP out of range (%ld max is +/-4GB): from %s (0x%08lX) to %s (0x%08lX)", 
 				displacement, atom->name(), atom->finalAddress(), referenceTargetAtomName(state, fixup), 
 				addressOf(state, fixup, &target));
 	}
@@ -2844,7 +2844,7 @@
 		
 		wholeBuffer = (uint8_t *)mmap(NULL, _fileSize, PROT_WRITE|PROT_READ, MAP_SHARED, fd, 0);
 		if ( wholeBuffer == MAP_FAILED )
-			throwf("can't create buffer of %llu bytes for output", _fileSize);
+			throwf("can't create buffer of %lu bytes for output", _fileSize);
 	} 
 	else {
 		if ( outputIsRegularFile )
@@ -2856,7 +2856,7 @@
 		// try to allocate buffer for entire output file content
 		wholeBuffer = (uint8_t*)calloc(_fileSize, 1);
 		if ( wholeBuffer == NULL )
-			throwf("can't create buffer of %llu bytes for output", _fileSize);
+			throwf("can't create buffer of %lu bytes for output", _fileSize);
 	}
 	
 	if ( _options.UUIDMode() == Options::kUUIDRandom ) {
@@ -4708,7 +4708,7 @@
 		if ( sect->isSectionHidden() )
 			continue;
 		bool codeSection = (sect->type() == ld::Section::typeCode);
-		if (log) fprintf(stderr, "sect: %s, address=0x%llX\n", sect->sectionName(), sect->address);
+		if (log) fprintf(stderr, "sect: %s, address=0x%lX\n", sect->sectionName(), sect->address);
 		for (std::vector<const ld::Atom*>::iterator ait = sect->atoms.begin(); ait != sect->atoms.end(); ++ait) {
 			const ld::Atom* atom = *ait;
 			const ld::Atom* target = NULL;
diff -ur ld64-274.2-orig/src/ld/Snapshot.h ld64-274.2/src/ld/Snapshot.h
--- ld64-274.2-orig/src/ld/Snapshot.h	2017-09-29 07:44:04.319672117 -0700
+++ ld64-274.2/src/ld/Snapshot.h	2017-09-29 20:32:25.044874041 -0700
@@ -88,7 +88,6 @@
 
     friend class SnapshotArchiveFileLog;
     
-    typedef std::vector<void(^)(void)> SnapshotLog;    
 
     struct strcompclass {
         bool operator() (const char *a, const char *b) const { return ::strcmp(a, b) < 0; }
@@ -128,7 +127,6 @@
     void addFrameworkArg(const char *framework);
     void addDylibArg(const char *dylib);
 
-    SnapshotLog fLog;           // log of events that recorded data in a snapshot prior to createSnapshot()
     bool fRecordArgs;           // record command line 
     bool fRecordObjects;        // record .o files 
     bool fRecordDylibSymbols;   // record referenced dylib/framework symbols
